					未来更新目录

1.DataPrintList的数据介绍保证和打印的label一致.
2.顺手把文件开启和创建全部更改为调用File类方法
3.再次创建一个DataPrintList向量储存第二个rom的数据的坐标和长度
4.二次的获取原始文件的数据,忽略或proj文件数据默认
5.对于非原始文件的数据,Song部分调整到最后(测试样本和table的位置相差过远的情况)
6.根据原始文件数据地址和长度,找出最匹配的修改数据,并打印标签,按从大到小的顺序.
7.对于原始文件数据地址已经使用,但是却没有用完,并且长度超过4字节的,再次记录进DataPrintList(重新排序）.
8.对于修改的数据，却使用了相同的地址。那么在从大到小排序的时候，对于重复的。在附加bool函数中，把label统一为第一个。但是不去重，因为还要打印。

根据前一个和后一个数据的衔接，把对齐的长度也算入len中，来纠正每个数据的长度。
这意味着这些数据全部为FF，那么不去按照这些固定的地址，而是把所有的可用数据位置全部都转化为字节FF呢。这样的话，似乎无法对应每个数据的长度。
如果是按照每个数据的长度一一对应，那么有4种情况
1.数据长度正好用完 这个可能性基本没有，只需要检测空余数据和写入数据是否都为空
2.空余数据剩余 这个可能性主要是可能没有合适的空余数据这样的话就把空余数据再次整理打印出清单，或者把空余数据全部转为FF
3.数据未打印完，空余数据无剩余。
4.空余数据剩余，数据未打印完。那么剩余的数据则新的自由数据上打印。
Song数据因为样本不能离得太远，所以样本和song数据都要在一块很大的地方上打印，或者song数据和样本数据直接选择在新的自由数据上打印。

这意味着song数据是最后才搞定（信息单独集列）的是吗？？？

对于昨天的那些song数据asm文件要转化为utf8。

主要绘制步骤：（绘制主要是针对自由空间的数据）
1.对于修改rom的数据（排除song和样本），按数据长度从大到小迭代，检查地址是否与4对齐，若不，则检查地址是否与2对齐。
2.根据修改rom的数据长度，找到匹配的自由空间，这个自由空间检查对齐方式是否与修改rom数据一致
，若不一致，则根据对齐规则重新设定起点和长度。然后比较长度是否足够，不足够搜寻下一个，若全部不符合，则这个修改rom的数据跳过。
3.对于符合的，根据自由空间的位置绘制org 0x8|地址，注释原数据标签和新覆盖标签。然后写入数据或者dw+标签。一旦写入完毕。则当前修改rom的数据信息从向量中删除。而当前被覆盖的自由数据的信息同样从向量中删除。
